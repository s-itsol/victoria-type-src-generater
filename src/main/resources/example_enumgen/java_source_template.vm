################################################################################
## [サンプル]生成JAVAソーステンプレート
##
##	＜vm変数-クラス型＞
##	$enumModel		：net.sitsol.victoria.tsgen.models.enumgen.EnumModel
##	$velocityCount	：Velocity搭載のループカウンタ ※デフォルト：1オリジン
##
##	＜テンプレート補足＞
##	下記インタフェースを実装する想定のテンプレートになっている。
##	https://github.com/s-itsol/victoria/blob/master/src/main/java/net/sitsol/victoria/enums/VctEnumAccessible.java
##
################################################################################
package ${enumModel.getPackageName()};

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import net.sitsol.victoria.enums.VctEnumAccessible;

/**
 * victoriaデモ用-Enum定数「${enumModel.getClassComment()}」
 * 
 * @author vitoria-type-src-generater
 */
public enum ${enumModel.getClassName()} implements VctEnumAccessible {

## フィールドモデルのループ
#foreach($enumFieldModel in $enumModel.getFieldModelList())##
## 2件目以降は「,」で区切る
#if($velocityCount > 1)##
	,
#end##
	/** ${enumFieldModel.getFieldComment()} ※${enumFieldModel.getCode()}：${enumFieldModel.getDecode()} */
	${enumFieldModel.getFieldName()}("${enumFieldModel.getCode()}", "${enumFieldModel.getDecode()}")
#end##
	;

	/**
	 * 全型リスト取得
	 *  ※読取専用で使う際には、暗黙の静的メソッド「values()」の方が若干軽量なのだが、
	 *    「10万回実行したら、30～80msほど遅かった」程度だったので、「ほぼ劣化は無し」という見立て。
	 *    かつ、eclipseの「呼び出し階層を開く」の検索対象にでき、調査／保守の観点からも、
	 *    アプリでは常にこちらの使用を推奨する。
	 */
	public static List<${enumModel.getClassName()}> getAllTypeList() {
		return new ArrayList<>( Arrays.asList(${enumModel.getClassName()}.values()) );
	}

	/**
	 * 型取得
	 * @param code コード値
	 * @return 型 ※該当なしの場合はnull
	 */
	public static ${enumModel.getClassName()} getType(String code) {
		
		${enumModel.getClassName()} retEnumType = null;
		
		// 型ループ
		for ( ${enumModel.getClassName()} enumType : ${enumModel.getClassName()}.values() ) {
			// コード値が一致したら、戻り値として確定
			if ( enumType.getCode().equals(code) ) {
				retEnumType = enumType;
				break;
			}
		}
		
		return retEnumType;
		
		// ※参考までに、ラムダ式でコーディングするなら以下。
		//   …なのだが、既に配列は生成済みなので、streamの効果は出ないはず。。
		//   であれば、わざわざJAVA8未満で動かないソースを生成させる理由も無い…という判断。
//		return Arrays.stream(${enumModel.getClassName()}.values())
//					.filter( enumType -> enumType.getCode().equals(code) )
//					.findFirst()
//					.orElse(null)
//		; 
	}

	/**
	 * デコード文字列取得
	 * @param code コード値
	 * @return デコード文字列 ※該当なしの場合は空文字
	 */
	public static String getDecode(String code) {
		${enumModel.getClassName()} targetType = getType(code);
		return targetType != null ? targetType.getDecode() : "";
	}

	/** コード値 */
	private final String code;
	/** デコード文字列 */
	private final String decode;

	/**
	 * コンストラクタ
	 * @param code コード値
	 * @param decode デコード文字列
	 */
	private ${enumModel.getClassName()}(String code, String decode) {
		this.code = code;
		this.decode = decode;
	}

	/**
	 * コード値
	 */
	@Override
	public String getCode() {
		return this.code;
	}

	/**
	 * デコード文字列
	 */
	@Override
	public String getDecode() {
		return this.decode;
	}

}
